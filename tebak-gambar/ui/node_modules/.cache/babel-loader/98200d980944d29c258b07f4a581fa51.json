{"ast":null,"code":"'use strict'; // @flow\n\n/**\n * A module for converting cryptographic keys into human-readable phrases.\n * @module niceware\n */\n\nconst bs = require('binary-search');\n\nconst wordlist = require('./wordlist');\n\nconst randomBytes = require('randombytes');\n\nconst MAX_PASSPHRASE_SIZE = 1024; // Max size of passphrase in bytes\n\n/**\n * @alias module:niceware\n */\n\nconst niceware = {};\n/**\n * Converts a byte array into a passphrase.\n * @param {Buffer} bytes The bytes to convert\n * @returns {Array.<string>}\n */\n\nniceware.bytesToPassphrase = function (bytes) {\n  // XXX: Uint8Array should only be used when this is called in the browser\n  // context.\n  if (!Buffer.isBuffer(bytes) && !(typeof window === 'object' && bytes instanceof window.Uint8Array)) {\n    throw new Error('Input must be a Buffer or Uint8Array.');\n  }\n\n  if (bytes.length % 2 === 1) {\n    throw new Error('Only even-sized byte arrays are supported.');\n  }\n\n  const words = [];\n\n  for (var entry of bytes.entries()) {\n    let index = entry[0];\n    let byte = entry[1];\n    let next = bytes[index + 1];\n\n    if (index % 2 === 0) {\n      let wordIndex = byte * 256 + next;\n      let word = wordlist[wordIndex];\n\n      if (!word) {\n        throw new Error('Invalid byte encountered');\n      } else {\n        words.push(word);\n      }\n    }\n  }\n\n  return words;\n};\n/**\n * Converts a phrase back into the original byte array.\n * @param {Array.<string>} words The words to convert\n * @returns {Buffer}\n */\n\n\nniceware.passphraseToBytes = function (words\n/* : Array<string> */\n) {\n  if (!Array.isArray(words)) {\n    throw new Error('Input must be an array.');\n  }\n\n  const bytes = Buffer.alloc(words.length * 2);\n  words.forEach((word, index) => {\n    if (typeof word !== 'string') {\n      throw new Error('Word must be a string.');\n    }\n\n    const wordIndex = bs(wordlist, word.toLowerCase(), (a, b) => {\n      if (a === b) {\n        return 0;\n      }\n\n      return a > b ? 1 : -1;\n    });\n\n    if (wordIndex < 0) {\n      throw new Error(`Invalid word: ${word}`);\n    }\n\n    bytes[2 * index] = Math.floor(wordIndex / 256);\n    bytes[2 * index + 1] = wordIndex % 256;\n  });\n  return bytes;\n};\n/**\n * Generates a random passphrase with the specified number of bytes.\n * NOTE: `size` must be an even number.\n * @param {number} size The number of random bytes to use\n * @returns {Array.<string>}\n */\n\n\nniceware.generatePassphrase = function (size\n/* : number */\n) {\n  if (typeof size !== 'number' || size < 0 || size > MAX_PASSPHRASE_SIZE) {\n    throw new Error(`Size must be between 0 and ${MAX_PASSPHRASE_SIZE} bytes.`);\n  }\n\n  const bytes = randomBytes(size);\n  return niceware.bytesToPassphrase(bytes);\n}; // For browserify\n\n\nif (typeof window === 'object') {\n  window.niceware = niceware;\n}\n\nmodule.exports = niceware;","map":{"version":3,"sources":["D:/Study/Coding/node-js/tebak-gambar/ui/node_modules/niceware/lib/main.js"],"names":["bs","require","wordlist","randomBytes","MAX_PASSPHRASE_SIZE","niceware","bytesToPassphrase","bytes","Buffer","isBuffer","window","Uint8Array","Error","length","words","entry","entries","index","byte","next","wordIndex","word","push","passphraseToBytes","Array","isArray","alloc","forEach","toLowerCase","a","b","Math","floor","generatePassphrase","size","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n// @flow\n/**\n * A module for converting cryptographic keys into human-readable phrases.\n * @module niceware\n */\n\nconst bs = require('binary-search')\nconst wordlist = require('./wordlist')\nconst randomBytes = require('randombytes')\n\nconst MAX_PASSPHRASE_SIZE = 1024 // Max size of passphrase in bytes\n\n/**\n * @alias module:niceware\n */\nconst niceware = {}\n\n/**\n * Converts a byte array into a passphrase.\n * @param {Buffer} bytes The bytes to convert\n * @returns {Array.<string>}\n */\nniceware.bytesToPassphrase = function (bytes) {\n  // XXX: Uint8Array should only be used when this is called in the browser\n  // context.\n  if (!Buffer.isBuffer(bytes) &&\n    !(typeof window === 'object' && bytes instanceof window.Uint8Array)) {\n    throw new Error('Input must be a Buffer or Uint8Array.')\n  }\n  if (bytes.length % 2 === 1) {\n    throw new Error('Only even-sized byte arrays are supported.')\n  }\n  const words = []\n  for (var entry of bytes.entries()) {\n    let index = entry[0]\n    let byte = entry[1]\n    let next = bytes[index + 1]\n    if (index % 2 === 0) {\n      let wordIndex = byte * 256 + next\n      let word = wordlist[wordIndex]\n      if (!word) {\n        throw new Error('Invalid byte encountered')\n      } else {\n        words.push(word)\n      }\n    }\n  }\n  return words\n}\n\n/**\n * Converts a phrase back into the original byte array.\n * @param {Array.<string>} words The words to convert\n * @returns {Buffer}\n */\nniceware.passphraseToBytes = function (words/* : Array<string> */) {\n  if (!Array.isArray(words)) {\n    throw new Error('Input must be an array.')\n  }\n\n  const bytes = Buffer.alloc(words.length * 2)\n\n  words.forEach((word, index) => {\n    if (typeof word !== 'string') {\n      throw new Error('Word must be a string.')\n    }\n    const wordIndex = bs(wordlist, word.toLowerCase(), (a, b) => {\n      if (a === b) {\n        return 0\n      }\n      return a > b ? 1 : -1\n    })\n    if (wordIndex < 0) {\n      throw new Error(`Invalid word: ${word}`)\n    }\n    bytes[2 * index] = Math.floor(wordIndex / 256)\n    bytes[2 * index + 1] = wordIndex % 256\n  })\n\n  return bytes\n}\n\n/**\n * Generates a random passphrase with the specified number of bytes.\n * NOTE: `size` must be an even number.\n * @param {number} size The number of random bytes to use\n * @returns {Array.<string>}\n */\nniceware.generatePassphrase = function (size/* : number */) {\n  if (typeof size !== 'number' || size < 0 || size > MAX_PASSPHRASE_SIZE) {\n    throw new Error(`Size must be between 0 and ${MAX_PASSPHRASE_SIZE} bytes.`)\n  }\n  const bytes = randomBytes(size)\n  return niceware.bytesToPassphrase(bytes)\n}\n\n// For browserify\nif (typeof window === 'object') {\n  window.niceware = niceware\n}\n\nmodule.exports = niceware\n"]},"metadata":{},"sourceType":"script"}